---
layout: layout.liquid
tags:
    - post
    - '2018'
title: Funciones de orden mayor (higher order functions) en JavaScript
date: 2018-07-26
---

# Funciones de orden mayor (higher order functions) en JavaScript

En JavaScript decimos que las funciones son first-class citizens o ciudadanas de primera clase (algunos términos de programación no tienen una muy buena traducción en español, ejemplo: monkey patching), esto significa que pueden ser tratadas como cualquier otro valor primitivo. En otras palabras, podemos asignar funciones a variables, pasar funciones como parámetros a otras funciones o retornar funciones desde otra función.
Una función de orden mayor (HOF) se denomina a (1) cualquier función que reciba una función como parámetro o (2) cualquier función que retorne otra función.

1. Funciones que reciben funciones como argumentos.
Dentro de la primera categoría de HOFs podemos destacar funciones como `Array.prototype.map`, que recibe como parámetro una función que describe cómo cada elemento del arreglo será transformado en orden de producir un nuevo arreglo.
const characters = [
  {
    firstName: 'Tulio’,
    lastName: 'Triviño’,
  },
  {
    firstName: 'Policarpo’,
    lastName: 'Avendaño’,
  },
  {
    firstName: 'Nicasio’,
    lastName: 'Fallido’,
  }
];
const names = characters.map(function(character) {
  return character.firstName + " " + character.lastName;
});
console.log(names); // ['Tulio Triviño', 'Policarpo Avendaño', 'Nicasio Fallido']
En este caso al llamar map en nuestro arreglo characters, pasamos una función (como parámetro/argumento) que concatena el nombre y apellido de nuestros personajes, produciendo un nuevo arreglo de “nombres completos”.
Tal como mencionamos anteriormente, las funciones en JavaScript pueden ser asignadas a variables o también ser declaradas. Sabiendo esto, podemos extraer la función que pasamos a map de la siguiente forma:
// ... usando funciones como expresiones
const getFullName = function(character) {
  return character.firstName + " " + character.lastName;
};
const names = characters.map(getFullName);
// ---------
// ... usando declaración de funciones
function getFullName(character) {
  return character.firstName + " " + character.lastName;
};
const names = characters.map(getFullName);
// ...
El resultado que obtenemos al evaluar names tras refactorizar nuestro código es idéntico (aunque existen diferencias entre declarar una función y asignar una función como expresión).
Para entender mejor cómo la función que pasamos a map es invocada, implementaremos nuestra propia versión sencilla de map:
De ahora en adelante todos los ejemplos están con notación de ES6.
const map = (source, fn) => {
  const output = [];
  for (const item of source) {
    const value = fn(item);
    output.push(value);
  }
  return output;
};
Nuestra versión de map recibe como parámetros un arreglo source y una función fn que describe como será transformado cada elemento del primero. Inicialmente generamos un arreglo vacío output, luego iteramos el arreglo source y por cada uno de sus elementos aplicamos la función fn, con dicho elemento como parámetro. Guardamos este resultado en la constante value y luego lo inyectamos en output. Finalmente, retornamos output.
Si aplicamos nuestra versión de map obtenemos el mismo resultado.
const names = map(characters, getFullName);
console.log(names); // ['Tulio Triviño', 'Policarpo Avendaño', 'Nicasio Fallido']
Lo importante es recalcar que nuestra versión de map no tiene conocimiento de los detalles de implementación de la función fn y sólo se preocupa de invocarla. Este es el mismo mecanismo que utilizamos cuando trabajamos con callbacks.
2. Funciones que retornan funciones.
Igualmente se consideran como HOFs aquellas funciones que retornan otra función. Esto es útil cuando queremos preservar valores en la función que retornemos a través de una clausura o closure, por ejemplo:
const add = function(x) {
  return function(y) {
    return x + y;
  }
};
const addTen = add(10); // Esto nos retorna la función anónima
const result = addTen(12); // Esto retorna `x + y`
console.log(result); // 22
En este caso tenemos una función add que retorna una función anónima. Nótese que el valor que retorna la función anónima está compuesto por los argumentos que pasamos tanto ésta como a add. addTen preserva el parámetro que le pasamos a add, aunque esta ya está fuera del contexto de ejecución, una vez que invocamos addTen.
En ES6 podemos expresar este tipo de funciones con una sintaxis mucho más reducida:
const add = x => y => x + y;
Veamos un ejemplo más práctico.
Digamos que tenemos un producto al cual aplicarle múltiples descuentos según las siguientes reglas de negocio:
10% de descuento obligatorio sobre el precio inicial.
5% de descuento extra (sobre el precio descontado) si el producto es de tipo SUPER_PREMIUM.
Otro 3% de descuento si es que el precio actual es mayor a $10.000.
Primero implementaremos una versión simple de nuestra función para aplicar estos descuentos y después veremos cómo aplicar HOFs para tener una solución más escalable:
const applyDiscounts = product => {
  // 10% de descuento obligatorio
  let finalPrice = product.price * 0.9;
  // 5% de descuento adicional para productos SUPER_PREMIUM  
  if (product.type === 'SUPER_PREMIUM') {
    finalPrice *= 0.95;
  }
  // 3% de descuento adicional si el precio es mayor a 10000
  if (finalPrice > 10000) {
    finalPrice *= 0.97;
  }
  return finalPrice;
};
const product = {
  name: 'Rélox 8000',
  type: 'SUPER_PREMIUM',
  price: 12300,
  description: 'Reloj de oro bañado en súper oro, con incrustaciones de diamantes y engranajes de plastigoma.'
};
// Aplicamos los descuentos
applyDiscounts(product); // 10201.005
El problema de la solución actual es que para cualquier cambio en los requerimientos, tenemos que modificar esta gran función. Si deseáramos agregar más condiciones para distintos tipos de producto, nuestra función se volvería más compleja y por lo tanto, más difícil de refactorizar con el tiempo. Lo que haremos entonces es modelar cada descuento como una función independiente y luego buscaremos una forma de aplicar estas funciones de forma genérica.
Escribamos las funciones que aplicarán descuentos:
// 10% de descuento obligatorio
const initialDiscount = price => price * 0.9;
// 5% de descuento adicional para productos SUPER_PREMIUM
const superPremiumDiscount = (price, type) => type === 'SUPER_PREMIUM' ? price * 0.95 : price;
// 3% de descuento adicional si el precio es mayor a 10000
const extraDiscount = price => price > 10000 ? price * 0.97 : price;

const applyDiscounts = ({ price, type }) => {
  let finalPrice = initialDiscount(price);
  finalPrice = superPremiumDiscount(finalPrice, type);
  finalPrice = extraDiscount(finalPrice);
return finalPrice;
};
// Aplicamos los descuentos
applyDiscounts(product); // 10201.005
Mucho mejor, pero no del todo.
Algo que podemos notar es que los descuentos son aplicados de forma secuencial, así como se ensamblan productos en una línea de producción.

Una línea de producción de gente feliz.
Podríamos modelar nuestra función applyDiscounts de tal forma que acepte un producto y una lista de descuentos a aplicar. Con esto nos aseguramos que la lógica de qué descuentos se aplican para nuestros productos ya no es parte de la implementación deapplyDiscounts:
const applyDiscounts = ({ price }, ...discounts) =>
  discounts.reduce((finalPrice, fn) => {
    return fn(finalPrice);
  }, price);
Aplicaríamos nuestra función así:
const finalPrice = applyDiscounts(product, discount1, discount2, /* ... */);
applyDiscounts se ha convertido en una HOF del primer tipo, ya que acepta otras funciones como parámetros.
Esta implementación incluso nos permite generalizar las funciones que aplican descuentos. Por ejemplo la función superPremiumDiscount ahora es innecesaria, pues si sabemos que aplicaremos descuentos a un producto SUPER_PREMIUM, ya no pasamos esta función a la lista de argumentos de applyDiscounts. Lo mismo se puede decir de initialDiscount y extraDiscount.
Nuestras nuevas funciones quedarían así:
const discountByPercentage = (price, percentage) => price * (percentage / 100);
const discountIfGreaterThan = (price, percentage, min) => price > min ? discountByPercentage(price, percentage) : price;
Ejecutemos nuestra solución (puedes copiar y pegar esto en la consola de tu navegador):
const product = {
  name: 'Rélox 8000',
  type: 'SUPER_PREMIUM',
  price: 12300,
  description: 'Reloj de oro bañado en súper oro, con incrustaciones de diamantes y engranajes de plastigoma.',
};
const discountByPercentage = (price, percentage) => price * (100 - percentage)/100;
const discountIfGreaterThan = (price, percentage, min) => price > min
  ? discountByPercentage(price, percentage)
  : price;
const applyDiscounts = ({ price }, ...discounts) =>
  discounts.reduce((finalPrice, fn) => fn(finalPrice), price);
console.log(applyDiscounts(product, discountByPercentage, discountIfGreaterThan));
Y el resultado es…

NaaaaaaaaaaaaaaaaaaaaaaN!!!
NaN
NaN
NaN!
NaN!!
NaN!!!
Y esto es esperable ya que nuestras funciones reciben más de un argumento. Cuando applyDiscounts llama a discountByPercentage, la ejecuta sólo con el primer argumento price, percentage queda entonces undefined, por ende la expresión price*(100-percentage)/100 se evalúa como NaN.
¿Cómo solucionamos esto? Con Higher Order Functions!
Refactorizamos nuestras funciones de descuentos para que retornen funciones:
const product = {
  name: 'Rélox 8000',
  type: 'SUPER_PREMIUM',
  price: 12300,
  description: 'Reloj de oro bañado en súper oro, con incrustaciones de diamantes y engranajes de plastigoma.',
};
const discountByPercentage = percentage => price => price * (100 - percentage)/100;
const discountIfGreaterThan = min => percentage => price => price > min
  ? discountByPercentage(percentage)(price)
  : price;
const applyDiscounts = ({ price }, ...discounts) =>
  discounts.reduce((finalPrice, fn) => fn(finalPrice), price);
const discounts = [
  discountByPercentage(10),       // 10% inicial
  discountByPercentage(5),        // 5% extra por ser SUPER_PREMIUM
  discountIfGreaterThan(10000)(3) // 3% extra si es mayor a 10000
];
console.log(applyDiscounts(product, ...discounts)); // 10201.005
WOOOOOOO-HOOOOO!!!!!! 🎊🎉🎈
Hemos aprendido a utilizar funciones de orden mayor!!!
En resumen
Las funciones de orden mayor nos sirven para componer lógica de forma más escalable y que podamos escribir código más terso y reutilizable en nuestros programas.
¿Te gustó lo que has leído? Sígueme en Medium o Twitter para más artículos sobre JavaScript y desarrollo web.