---
layout: layout.liquid
tags:
    - post
    - '2018'
title: Funciones de orden mayor (higher order functions) en JavaScript
date: 2018-07-26
---

# Funciones de orden mayor (higher order functions) en JavaScript

En JavaScript decimos que las funciones son first-class citizens o ciudadanas de primera clase (algunos tÃ©rminos de programaciÃ³n no tienen una muy buena traducciÃ³n en espaÃ±ol, ejemplo: monkey patching), esto significa que pueden ser tratadas como cualquier otro valor primitivo. En otras palabras, podemos asignar funciones a variables, pasar funciones como parÃ¡metros a otras funciones o retornar funciones desde otra funciÃ³n.
Una funciÃ³n de orden mayor (HOF) se denomina a (1) cualquier funciÃ³n que reciba una funciÃ³n como parÃ¡metro o (2) cualquier funciÃ³n que retorne otra funciÃ³n.

1. Funciones que reciben funciones como argumentos.
Dentro de la primera categorÃ­a de HOFs podemos destacar funciones como `Array.prototype.map`, que recibe como parÃ¡metro una funciÃ³n que describe cÃ³mo cada elemento del arreglo serÃ¡ transformado en orden de producir un nuevo arreglo.
const characters = [
  {
    firstName: 'Tulioâ€™,
    lastName: 'TriviÃ±oâ€™,
  },
  {
    firstName: 'Policarpoâ€™,
    lastName: 'AvendaÃ±oâ€™,
  },
  {
    firstName: 'Nicasioâ€™,
    lastName: 'Fallidoâ€™,
  }
];
const names = characters.map(function(character) {
  return character.firstName + " " + character.lastName;
});
console.log(names); // ['Tulio TriviÃ±o', 'Policarpo AvendaÃ±o', 'Nicasio Fallido']
En este caso al llamar map en nuestro arreglo characters, pasamos una funciÃ³n (como parÃ¡metro/argumento) que concatena el nombre y apellido de nuestros personajes, produciendo un nuevo arreglo de â€œnombres completosâ€.
Tal como mencionamos anteriormente, las funciones en JavaScript pueden ser asignadas a variables o tambiÃ©n ser declaradas. Sabiendo esto, podemos extraer la funciÃ³n que pasamos a map de la siguiente forma:
// ... usando funciones como expresiones
const getFullName = function(character) {
  return character.firstName + " " + character.lastName;
};
const names = characters.map(getFullName);
// ---------
// ... usando declaraciÃ³n de funciones
function getFullName(character) {
  return character.firstName + " " + character.lastName;
};
const names = characters.map(getFullName);
// ...
El resultado que obtenemos al evaluar names tras refactorizar nuestro cÃ³digo es idÃ©ntico (aunque existen diferencias entre declarar una funciÃ³n y asignar una funciÃ³n como expresiÃ³n).
Para entender mejor cÃ³mo la funciÃ³n que pasamos a map es invocada, implementaremos nuestra propia versiÃ³n sencilla de map:
De ahora en adelante todos los ejemplos estÃ¡n con notaciÃ³n de ES6.
const map = (source, fn) => {
  const output = [];
  for (const item of source) {
    const value = fn(item);
    output.push(value);
  }
  return output;
};
Nuestra versiÃ³n de map recibe como parÃ¡metros un arreglo source y una funciÃ³n fn que describe como serÃ¡ transformado cada elemento del primero. Inicialmente generamos un arreglo vacÃ­o output, luego iteramos el arreglo source y por cada uno de sus elementos aplicamos la funciÃ³n fn, con dicho elemento como parÃ¡metro. Guardamos este resultado en la constante value y luego lo inyectamos en output. Finalmente, retornamos output.
Si aplicamos nuestra versiÃ³n de map obtenemos el mismo resultado.
const names = map(characters, getFullName);
console.log(names); // ['Tulio TriviÃ±o', 'Policarpo AvendaÃ±o', 'Nicasio Fallido']
Lo importante es recalcar que nuestra versiÃ³n de map no tiene conocimiento de los detalles de implementaciÃ³n de la funciÃ³n fn y sÃ³lo se preocupa de invocarla. Este es el mismo mecanismo que utilizamos cuando trabajamos con callbacks.
2. Funciones que retornan funciones.
Igualmente se consideran como HOFs aquellas funciones que retornan otra funciÃ³n. Esto es Ãºtil cuando queremos preservar valores en la funciÃ³n que retornemos a travÃ©s de una clausura o closure, por ejemplo:
const add = function(x) {
  return function(y) {
    return x + y;
  }
};
const addTen = add(10); // Esto nos retorna la funciÃ³n anÃ³nima
const result = addTen(12); // Esto retorna `x + y`
console.log(result); // 22
En este caso tenemos una funciÃ³n add que retorna una funciÃ³n anÃ³nima. NÃ³tese que el valor que retorna la funciÃ³n anÃ³nima estÃ¡ compuesto por los argumentos que pasamos tanto Ã©sta como a add. addTen preserva el parÃ¡metro que le pasamos a add, aunque esta ya estÃ¡ fuera del contexto de ejecuciÃ³n, una vez que invocamos addTen.
En ES6 podemos expresar este tipo de funciones con una sintaxis mucho mÃ¡s reducida:
const add = x => y => x + y;
Veamos un ejemplo mÃ¡s prÃ¡ctico.
Digamos que tenemos un producto al cual aplicarle mÃºltiples descuentos segÃºn las siguientes reglas de negocio:
10% de descuento obligatorio sobre el precio inicial.
5% de descuento extra (sobre el precio descontado) si el producto es de tipo SUPER_PREMIUM.
Otro 3% de descuento si es que el precio actual es mayor a $10.000.
Primero implementaremos una versiÃ³n simple de nuestra funciÃ³n para aplicar estos descuentos y despuÃ©s veremos cÃ³mo aplicar HOFs para tener una soluciÃ³n mÃ¡s escalable:
const applyDiscounts = product => {
  // 10% de descuento obligatorio
  let finalPrice = product.price * 0.9;
  // 5% de descuento adicional para productos SUPER_PREMIUM  
  if (product.type === 'SUPER_PREMIUM') {
    finalPrice *= 0.95;
  }
  // 3% de descuento adicional si el precio es mayor a 10000
  if (finalPrice > 10000) {
    finalPrice *= 0.97;
  }
  return finalPrice;
};
const product = {
  name: 'RÃ©lox 8000',
  type: 'SUPER_PREMIUM',
  price: 12300,
  description: 'Reloj de oro baÃ±ado en sÃºper oro, con incrustaciones de diamantes y engranajes de plastigoma.'
};
// Aplicamos los descuentos
applyDiscounts(product); // 10201.005
El problema de la soluciÃ³n actual es que para cualquier cambio en los requerimientos, tenemos que modificar esta gran funciÃ³n. Si deseÃ¡ramos agregar mÃ¡s condiciones para distintos tipos de producto, nuestra funciÃ³n se volverÃ­a mÃ¡s compleja y por lo tanto, mÃ¡s difÃ­cil de refactorizar con el tiempo. Lo que haremos entonces es modelar cada descuento como una funciÃ³n independiente y luego buscaremos una forma de aplicar estas funciones de forma genÃ©rica.
Escribamos las funciones que aplicarÃ¡n descuentos:
// 10% de descuento obligatorio
const initialDiscount = price => price * 0.9;
// 5% de descuento adicional para productos SUPER_PREMIUM
const superPremiumDiscount = (price, type) => type === 'SUPER_PREMIUM' ? price * 0.95 : price;
// 3% de descuento adicional si el precio es mayor a 10000
const extraDiscount = price => price > 10000 ? price * 0.97 : price;

const applyDiscounts = ({ price, type }) => {
  let finalPrice = initialDiscount(price);
  finalPrice = superPremiumDiscount(finalPrice, type);
  finalPrice = extraDiscount(finalPrice);
return finalPrice;
};
// Aplicamos los descuentos
applyDiscounts(product); // 10201.005
Mucho mejor, pero no del todo.
Algo que podemos notar es que los descuentos son aplicados de forma secuencial, asÃ­ como se ensamblan productos en una lÃ­nea de producciÃ³n.

Una lÃ­nea de producciÃ³n de gente feliz.
PodrÃ­amos modelar nuestra funciÃ³n applyDiscounts de tal forma que acepte un producto y una lista de descuentos a aplicar. Con esto nos aseguramos que la lÃ³gica de quÃ© descuentos se aplican para nuestros productos ya no es parte de la implementaciÃ³n deapplyDiscounts:
const applyDiscounts = ({ price }, ...discounts) =>
  discounts.reduce((finalPrice, fn) => {
    return fn(finalPrice);
  }, price);
AplicarÃ­amos nuestra funciÃ³n asÃ­:
const finalPrice = applyDiscounts(product, discount1, discount2, /* ... */);
applyDiscounts se ha convertido en una HOF del primer tipo, ya que acepta otras funciones como parÃ¡metros.
Esta implementaciÃ³n incluso nos permite generalizar las funciones que aplican descuentos. Por ejemplo la funciÃ³n superPremiumDiscount ahora es innecesaria, pues si sabemos que aplicaremos descuentos a un producto SUPER_PREMIUM, ya no pasamos esta funciÃ³n a la lista de argumentos de applyDiscounts. Lo mismo se puede decir de initialDiscount y extraDiscount.
Nuestras nuevas funciones quedarÃ­an asÃ­:
const discountByPercentage = (price, percentage) => price * (percentage / 100);
const discountIfGreaterThan = (price, percentage, min) => price > min ? discountByPercentage(price, percentage) : price;
Ejecutemos nuestra soluciÃ³n (puedes copiar y pegar esto en la consola de tu navegador):
const product = {
  name: 'RÃ©lox 8000',
  type: 'SUPER_PREMIUM',
  price: 12300,
  description: 'Reloj de oro baÃ±ado en sÃºper oro, con incrustaciones de diamantes y engranajes de plastigoma.',
};
const discountByPercentage = (price, percentage) => price * (100 - percentage)/100;
const discountIfGreaterThan = (price, percentage, min) => price > min
  ? discountByPercentage(price, percentage)
  : price;
const applyDiscounts = ({ price }, ...discounts) =>
  discounts.reduce((finalPrice, fn) => fn(finalPrice), price);
console.log(applyDiscounts(product, discountByPercentage, discountIfGreaterThan));
Y el resultado esâ€¦

NaaaaaaaaaaaaaaaaaaaaaaN!!!
NaN
NaN
NaN!
NaN!!
NaN!!!
Y esto es esperable ya que nuestras funciones reciben mÃ¡s de un argumento. Cuando applyDiscounts llama a discountByPercentage, la ejecuta sÃ³lo con el primer argumento price, percentage queda entonces undefined, por ende la expresiÃ³n price*(100-percentage)/100 se evalÃºa como NaN.
Â¿CÃ³mo solucionamos esto? Con Higher Order Functions!
Refactorizamos nuestras funciones de descuentos para que retornen funciones:
const product = {
  name: 'RÃ©lox 8000',
  type: 'SUPER_PREMIUM',
  price: 12300,
  description: 'Reloj de oro baÃ±ado en sÃºper oro, con incrustaciones de diamantes y engranajes de plastigoma.',
};
const discountByPercentage = percentage => price => price * (100 - percentage)/100;
const discountIfGreaterThan = min => percentage => price => price > min
  ? discountByPercentage(percentage)(price)
  : price;
const applyDiscounts = ({ price }, ...discounts) =>
  discounts.reduce((finalPrice, fn) => fn(finalPrice), price);
const discounts = [
  discountByPercentage(10),       // 10% inicial
  discountByPercentage(5),        // 5% extra por ser SUPER_PREMIUM
  discountIfGreaterThan(10000)(3) // 3% extra si es mayor a 10000
];
console.log(applyDiscounts(product, ...discounts)); // 10201.005
WOOOOOOO-HOOOOO!!!!!! ğŸŠğŸ‰ğŸˆ
Hemos aprendido a utilizar funciones de orden mayor!!!
En resumen
Las funciones de orden mayor nos sirven para componer lÃ³gica de forma mÃ¡s escalable y que podamos escribir cÃ³digo mÃ¡s terso y reutilizable en nuestros programas.
Â¿Te gustÃ³ lo que has leÃ­do? SÃ­gueme en Medium o Twitter para mÃ¡s artÃ­culos sobre JavaScript y desarrollo web.